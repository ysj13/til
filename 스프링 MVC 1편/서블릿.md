# 서블릿
## 서블릿의 등장 배경
우리가 웹 어플리케이션 서버를 처음부터 직접 구현하려면
서버 TCP/IP 연결, HTTP 요청 메시지와 HTTP body 내용을 파싱한 후 비즈니스 로직을 실행해야 한다.
그리고 비즈니스 로직이 끝나면 다시 HTTP 응답 메시지를 생성하고...

위와 같은 수많은 기능을 직접 구현해야 한다.
이는 상당히 비효율적이다.  사실 가장 중요한건 비즈니스 로직인데
비즈니스 로직 이외의 내용들을 개발하는데 시간을 다 써야 한다.

그래서 등장한게 **Servlet** 이다. 
```java
@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
	@Override
	protected void service(HttpServletRequest request, HttpServletResponse response) {
		// 애플리케이션 로직
	}
}
```

* HTTP 요청 정보를 편리하게 사용할수 있는 HttpServletRequest
* HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse
* 개발자는 HTTP 스펙을 매우 편리하게 사용할 수 있다.

## HTTP 요청, 응답 흐름
1. http 요청(localhost:8080/hello)
2. WAS 서버에서 http 요청 메시지를 기반으로 Request, Response 객체를 새로 생성한다.
3. 위에서 만들었던 HelloServlet 이 실행된다(Request)
4. HelloServlet 이 종료될때 Response 객체 정보로 HTTP 응답 생성(Response)
5. 웹 브라우저에게 응답 메시지 전달.

### HTTP 요청 시
* WAS 는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출
* 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
* 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력
* WAS 는 Response 객체에 담겨있는 내용으로 HTTP 응답정보를 생성

## 서블릿 컨테이너
* 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 한다.
* 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리해준다.
* 서블릿 객체는 싱글톤으로 관리된다. (Request, Response 객체는 새로 생성됨.)
	* 고객의 요청이 들어올때 마다 계속 객체를 새로 생성하는것은 비효율적이다.
	* 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용하는 방식.
	* 모든 고객의 요청은 동일한 서블릿 객체 인스턴스에 접근하게 된다.
	* **공유 변수 사용 주의**
	* 서블릿 컨테이너 종료 시 함께 종료
* JSP도 서블릿으로 변환되어서 사용
* 동시 요청을 위한 멀티쓰레드 처리 지원
